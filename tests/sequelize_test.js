'use strict';

const { expect, assert } = require('chai');
const { DataTypes, Sequelize } = require('../source');
const dialect = 'postgres';
const _ = require('lodash');

const qq = str => {
  if (dialect === 'postgres' || dialect === 'mssql') {
    return `"${str}"`;
  }
  if (dialect === 'mysql' || dialect === 'mariadb' || dialect === 'sqlite') {
    return `\`${str}\``;
  }
  return str;
};

const config = {
  rand: () => {
    return parseInt(Math.random() * 999, 10);
  }
};

describe('Sequelize', () => {
  describe('truncate', () => {
    // Edit reason:
    // CRDB does not guarantee ids to start at 1
    it('truncates all models', async function () {
      const Project = this.sequelize.define(`project${config.rand()}`, {
        id: {
          type: DataTypes.INTEGER,
          primaryKey: true,
          autoIncrement: true
        },
        title: DataTypes.STRING
      });

      await this.sequelize.sync({ force: true });
      // Added ID, as it is expected to be 1
      const project = await Project.create({ id: 1, title: 'bla' });
      expect(project).to.exist;
      expect(project.title).to.equal('bla');
      expect(project.id).to.equal(1);
      await this.sequelize.truncate();
      const projects = await Project.findAll({});
      expect(projects).to.exist;
      expect(projects).to.have.length(0);
    });
  });

  describe('sync', () => {
    // Edit reason:
    // Error message CRDB provides does not quote "bar"
    it('fails with incorrect database credentials (1)', async function () {
      this.sequelizeWithInvalidCredentials = new Sequelize(
        'omg',
        'bar',
        null,
        _.omit(this.sequelize.options, ['host'])
      );

      const User2 = this.sequelizeWithInvalidCredentials.define('User', {
        name: DataTypes.STRING,
        bio: DataTypes.TEXT
      });

      try {
        await User2.sync();
        expect.fail();
      } catch (err) {
        assert(
          [
            'fe_sendauth: no password supplied',
            'role "bar" does not exist',
            'FATAL:  role "bar" does not exist',
            'password authentication failed for user "bar"',
            // Added the error message generated by CRDB
            'password authentication failed for user bar'
          ].includes(err.message.trim())
        );
      }
    });
  });

  describe('define', () => {
    describe('transaction', () => {
      beforeEach(async function () {
        const sequelize = await this.sequelize;
        this.sequelizeWithTransaction = sequelize;
      });

      // Skip reason:
      // CRDB transactions have stronger locking restrictions so that a transaction
      // writing will block reads on the same object from a different transaction.
      it.skip('correctly handles multiple transactions', async function () {
        const TransactionTest = this.sequelizeWithTransaction.define(
          'TransactionTest',
          { name: DataTypes.STRING },
          { timestamps: false }
        );
        const aliasesMapping = new Map([['_0', 'cnt']]);

        const count = async transaction => {
          const sql = this.sequelizeWithTransaction
            .getQueryInterface()
            .queryGenerator.selectQuery('TransactionTests', {
              attributes: [['count(*)', 'cnt']]
            });

          const result = await this.sequelizeWithTransaction.query(sql, {
            plain: true,
            transaction,
            aliasesMapping
          });

          return parseInt(result.cnt, 10);
        };

        await TransactionTest.sync({ force: true });
        const t1 = await this.sequelizeWithTransaction.transaction();
        this.t1 = t1;
        await this.sequelizeWithTransaction.query(
          `INSERT INTO ${qq('TransactionTests')} (${qq(
            'name'
          )}) VALUES ('foo');`,
          { transaction: t1 }
        );
        const t2 = await this.sequelizeWithTransaction.transaction();
        this.t2 = t2;
        await this.sequelizeWithTransaction.query(
          `INSERT INTO ${qq('TransactionTests')} (${qq(
            'name'
          )}) VALUES ('bar');`,
          { transaction: t2 }
        );
        await expect(count()).to.eventually.equal(0);
        await expect(count(this.t1)).to.eventually.equal(1);
        await expect(count(this.t2)).to.eventually.equal(1);
        await this.t2.rollback();
        await expect(count()).to.eventually.equal(0);
        await this.t1.commit();

        await expect(count()).to.eventually.equal(1);
      });
    });
  });
});
